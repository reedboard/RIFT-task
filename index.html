<!DOCTYPE html>
<html>
<head>
  <title>RIFT Task</title>
  <script src="https://unpkg.com/jspsych@8.2.2"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-preload@2.1.0"></script>
  <link href="https://unpkg.com/jspsych@8.2.2/css/jspsych.css" rel="stylesheet" type="text/css" />
  <style>
    .arena-item:hover {
      cursor: pointer;
      opacity: 0.8;
    }
    .stimulus-container {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin: 20px 0;
      gap: 100px;
    }

    .countdown-display {
      position: fixed;
      top: 50px;
      right: 70px;
      background: #f0f0f0;
      padding: 10px 15px;
      border-radius: 8px;
      border: 2px solid #fa0101;
      font-weight: bold;
      font-size: 25px;
    }
    .arena-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      grid-template-rows: repeat(6, 1fr);
      gap: 15px;
      max-width: 900px;
      margin: 20px auto;
      padding: 20px;
    }
    .arena-fractal {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px;
      border: 3px solid #ccc;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .arena-fractal:hover {
      opacity: 0.8;
    }
    .arena-fractal.selected {
      border-color: #2196F3;
      background-color: #e3f2fd;
    }
    .arena-fractal.known {
      border-color: #4CAF50;
    }
    .arena-fractal.unknown {
      border-color: #FF9800;
    }
  </style>
</head>
<body></body>
<script>
  const jsPsych = initJsPsych({
    on_finish: () => {
      console.log("Experiment completed");
      jsPsych.data.displayData();
    }
  });

  let timeline = [];

  // Define reward ranges (ensuring no overlap for clear learning)
  const rewardRanges = [
    // Many overlapping low-value ranges
    [1, 5], [2, 6], [3, 7], [4, 8], [5, 9], [6, 10], [7, 11], [8, 12],
    [10, 15], [12, 17], [15, 20], [17, 22], [20, 25], [22, 27], [25, 30], [27, 32],
    [30, 35], [32, 37], [35, 40], [37, 42], [40, 45], [42, 47], [45, 50],

    // Moderate value ranges (less frequent)
    [50, 60], [60, 70], [70, 80], [80, 90], [90, 100],

    // Rare high-value ranges
    [100, 150], [150, 200], [200, 250], [250, 300]
  ];

  // Fractal image filenames - using first 42 for the arena
  const fractalFilenames = [
    'SHINEd_fractal_001.png', 'SHINEd_fractal_002.png', 'SHINEd_fractal_004.png',
    'SHINEd_fractal_005.png', 'SHINEd_fractal_006.png', 'SHINEd_fractal_013.png',
    'SHINEd_fractal_016.png', 'SHINEd_fractal_021.png', 'SHINEd_fractal_022.png',
    'SHINEd_fractal_034.png', 'SHINEd_fractal_047.png', 'SHINEd_fractal_049.png',
    'SHINEd_fractal_056.png', 'SHINEd_fractal_076.png', 'SHINEd_fractal_078.png',
    'SHINEd_fractal_087.png', 'SHINEd_fractal_1005.png', 'SHINEd_fractal_1007.png',
    'SHINEd_fractal_101.png', 'SHINEd_fractal_1013.png', 'SHINEd_fractal_1017.png',
    'SHINEd_fractal_1018.png', 'SHINEd_fractal_1019.png', 'SHINEd_fractal_1020.png',
    'SHINEd_fractal_1021.png', 'SHINEd_fractal_1022.png', 'SHINEd_fractal_1029.png',
    'SHINEd_fractal_103.png', 'SHINEd_fractal_1046.png', 'SHINEd_fractal_1048.png',
    'SHINEd_fractal_105.png', 'SHINEd_fractal_1058.png', 'SHINEd_fractal_106.png',
    'SHINEd_fractal_1061.png', 'SHINEd_fractal_1062.png', 'SHINEd_fractal_1077.png',
    'SHINEd_fractal_1079.png', 'SHINEd_fractal_1080.png', 'SHINEd_fractal_1087.png',
    'SHINEd_fractal_1090.png', 'SHINEd_fractal_1094.png', 'SHINEd_fractal_1103.png',
    'SHINEd_fractal_1108.png'
  ];

  // Create stimulus pool with actual fractal images (42 total for arena)
  let all_stimuli = fractalFilenames.map((filename, index) => ({
    id: `fractal_${index + 1}`,
    image: `stimuli_400_fractals/${filename}`,
    unlocked: false,
    reward_range: null,
    available_for_learning: index < 21 // First 21 available for learning phase
  }));

  // Shuffle only the learning stimuli
  let learning_stimuli = all_stimuli.filter(s => s.available_for_learning);
  learning_stimuli = jsPsych.randomization.shuffle(learning_stimuli);
  
  let unlocked_stimuli = [];
  let used_reward_ranges = [];

  // Preload images
  timeline.push({
    type: jsPsychPreload,
    images: all_stimuli.map(s => s.image)
  });

  // Function to create fractal HTML
  function createFractalHTML(stimulus, width = 150) {
    return `<img src="${stimulus.image}" width="${width}" height="${width}">`;
  }

  // Function to assign reward range
  function assignRewardRange() {
    const availableRanges = rewardRanges.filter(range => 
      !used_reward_ranges.some(used => used[0] === range[0] && used[1] === range[1])
    );
    
    if (availableRanges.length === 0) {
      // If all ranges are used, reset and reuse
      used_reward_ranges = [];
      return rewardRanges[Math.floor(Math.random() * rewardRanges.length)];
    }
    
    const selected = availableRanges[Math.floor(Math.random() * availableRanges.length)];
    used_reward_ranges.push(selected);
    return selected;
  }

  // Instructions
  timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <div style="max-width: 500px; margin: 0 auto; text-align: center;">
        <h2>RIFT Task</h2>
        <p>Choose between known and unknown reward options. Known options show point ranges, unknown options show "???" but reveal their value when selected.</p>
        <p><strong>Press F for LEFT, J for RIGHT</strong></p>
        <p>After 21 trials, you'll enter <strong>the Arena.<strong></p>
        <p><strong>Press any key to begin</strong></p>
      </div>
    `,
    choices: "ALL_KEYS"
  });

  // First trial: force learning by presenting two unknowns from learning pool
  if (learning_stimuli.length >= 2) {
    const unknown1 = learning_stimuli[0];
    const unknown2 = learning_stimuli[1];

    timeline.push({
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="countdown-display">Trials to Arena: 21</div>
        <div class="stimulus-container">
          <div class="stimulus-option">
            ${createFractalHTML(unknown1)}
            <p style="font-size: 18px; font-weight: bold;">???</p>
            <p><strong>F: CHOOSE LEFT</strong></p>
          </div>
          <div class="stimulus-option">
            ${createFractalHTML(unknown2)}
            <p style="font-size: 18px; font-weight: bold;">???</p>
            <p><strong>J: CHOOSE RIGHT</strong></p>
          </div>
        </div>
      `,
      choices: ['f', 'j'],
      data: {
        trial_type: 'forced_learning',
        trial_number: 0,
        left_stimulus: unknown1.id,
        right_stimulus: unknown2.id
      },
      on_finish: function(data) {
        const chosen = data.response === 'f' ? unknown1 : unknown2;
        const assigned_range = assignRewardRange();
        
        chosen.unlocked = true;
        chosen.reward_range = assigned_range;
        unlocked_stimuli.push(chosen);
        
        data.chosen_stimulus = chosen.id;
        data.assigned_range = assigned_range;
        
        console.log(`Unlocked stimulus ${chosen.id} with range [${assigned_range[0]}, ${assigned_range[1]}]`);
      }
    });

    // Feedback for first trial
    timeline.push({
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        const lastTrial = jsPsych.data.get().last(1).values()[0];
        const range = lastTrial.assigned_range;
        return `
          <div style="text-align: center;">
            <h3>Stimulus Unlocked!</h3>
            <p>This fractal will give you <strong>${range[0]} to ${range[1]} points</strong> in future trials.</p>
          </div>
        `;
      },
      choices: "NO_KEYS",
      trial_duration: 1500
    });
  }
  
  // Main choice trials (20 more trials, for 21 total)
  for (let i = 1; i <= 20; i++) {
    timeline.push({
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Get available stimuli from learning pool only
        const available_unlocked = unlocked_stimuli.filter(s => s.unlocked && s.available_for_learning);
        const available_unknown = learning_stimuli.filter(s => !s.unlocked);
        
        const trialsLeft = 21 - i;
        
        if (available_unlocked.length === 0 || available_unknown.length === 0) {
          return `
            <div class="countdown-display">Trials to Arena: ${trialsLeft}</div>
            <p>No more stimuli available. Press any key to continue.</p>
          `;
        }
        
        // Randomly select one known and one unknown
        const known = jsPsych.randomization.sampleWithoutReplacement(available_unlocked, 1)[0];
        const unknown = jsPsych.randomization.sampleWithoutReplacement(available_unknown, 1)[0];
        
        const knownHTML = `
          <div class="stimulus-option">
            ${createFractalHTML(known)}
            <p style="font-size: 16px; font-weight: bold;">${known.reward_range[0]}â€“${known.reward_range[1]} Points</p>
            <p><strong> ACCEPT </strong></p>
          </div>
        `;
        
        const unknownHTML = `
          <div class="stimulus-option">
            ${createFractalHTML(unknown)}
            <p style="font-size: 18px; font-weight: bold;">???</p>
            <p><strong> REVEAL </strong></p>
          </div>
        `;

        // Randomly assign side
        const known_on_left = Math.random() < 0.5;
        const leftStim = known_on_left ? knownHTML : unknownHTML;
        const rightStim = known_on_left ? unknownHTML : knownHTML;

        // Store trial info in data property for access in on_finish
        return `
          <div class="countdown-display">Trials to Arena: ${trialsLeft}</div>
          <div class="stimulus-container">
            ${leftStim}
            ${rightStim}
          </div>
          <script>
            // Store trial info in a way that on_finish can access
            window.currentTrialInfo = {
              known: ${JSON.stringify(known)},
              unknown: ${JSON.stringify(unknown)},
              known_on_left: ${known_on_left}
            };
          </script>
        `;
      },
      choices: ['f', 'j'],
      data: {
        trial_type: 'choice',
        trial_number: i
      },
      on_finish: function(data) {
        const trialInfo = window.currentTrialInfo;
        
        if (!trialInfo || !trialInfo.known || !trialInfo.unknown) {
          data.error = "Missing trial info";
          return;
        }
        
        const known = trialInfo.known;
        const unknown = trialInfo.unknown;
        const known_on_left = trialInfo.known_on_left;
        
        data.known_stimulus = known.id;
        data.known_range = known.reward_range;
        data.unknown_stimulus = unknown.id;
        data.known_on_left = known_on_left;
        
        // Determine what was actually chosen based on key press and layout
        const chose_left = (data.response === 'f');
        const chose_known = (chose_left && known_on_left) || (!chose_left && !known_on_left);
        
        if (chose_known) {
          // Chose the known reward
          const [min, max] = known.reward_range;
          const points = Math.floor(Math.random() * (max - min + 1)) + min;
          
          data.choice = 'accept';
          data.revealed = false;
          data.points_awarded = points;
          
          console.log(`Trial ${i}: Accepted ${known.id}, awarded ${points} points`);
        } else {
          // Chose to reveal unknown
          const assigned_range = assignRewardRange();
          
          // Find the unknown stimulus in the learning_stimuli array and update it
          const unknownStimIndex = learning_stimuli.findIndex(s => s.id === unknown.id);
          if (unknownStimIndex !== -1) {
            learning_stimuli[unknownStimIndex].unlocked = true;
            learning_stimuli[unknownStimIndex].reward_range = assigned_range;
            unlocked_stimuli.push(learning_stimuli[unknownStimIndex]);
          }
          
          data.choice = 'reveal';
          data.revealed = true;
          data.assigned_range = assigned_range;
          data.points_awarded = 0;
          
          console.log(`Trial ${i}: Revealed ${unknown.id} with range [${assigned_range[0]}, ${assigned_range[1]}]`);
        }
      }
    });

    // Feedback after each trial
  timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
      const lastTrial = jsPsych.data.get().last(1).values()[0];
      let feedback = "";

      if (lastTrial.choice === 'reveal') {
        const range = lastTrial.assigned_range;
        feedback = `
          <div style="text-align: center;">
            <h3>New Fractal Unlocked!</h3>
            <p>This fractal will give you <strong>${range[0]} to ${range[1]} points</strong> in future trials.</p>
            <p>You gained <strong>0 points</strong> this trial.</p>
          </div>
        `;
      } else {
        feedback = `
          <div style="text-align: center;">
            <h3>Reward Collected!</h3>
            <p>You earned <strong>${lastTrial.points_awarded} points</strong> this trial.</p>
          </div>
        `;
      }

      return feedback;
    },
    choices: "NO_KEYS",          //  prevent keypresses
    trial_duration: 1500         // fixed duration in ms
  });

  }
  // Arena instructions
  timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
      const known_count = unlocked_stimuli.filter(s => s.unlocked).length;
      const unknown_count = 42 - known_count;
      
      return `
        <div style="text-align: center; max-width: 600px; margin: 0 auto;">
          <h2>Welcome to the Arena!</h2>
          <p>Now you can choose from all 42 fractals arranged in a 6x7 grid.</p>
          <p><strong>Available options:</strong></p>
          <p>â€¢ ${known_count} Known fractals (showing point ranges)</p>
          <p>â€¢ ${unknown_count} Unknown fractals (showing "???")</p>
          <p><strong>Select exactly 3 fractals</strong> to maximize your points.</p>
          <p>Click on fractals to select them (they'll turn blue when selected).</p>
          <p>Unknown fractals will reveal their point ranges when selected!</p>
          <p><em>Press any key to enter the Arena</em></p>
        </div>
      `;
    },
    choices: "ALL_KEYS"
  });

  // Arena trial
  // Shuffle once and reuse
  let arena_stimuli = jsPsych.randomization.shuffle(all_stimuli);

  timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
      // Assign reward ranges to all unknowns before rendering
      arena_stimuli.forEach(stim => {
        if (!stim.unlocked && !stim.reward_range) {
          stim.reward_range = assignRewardRange();
        }
      });

      let html = `
        <h2 style="text-align: center;">Arena - Select 3 Fractals</h2>
        <div id="selection-counter" style="text-align: center; margin: 10px 0;">
          <p>Selected: <span id="count">0</span>/3</p>
        </div>
        <div class="arena-grid" id="arena">
      `;

      arena_stimuli.forEach((stim, index) => {
        const statusClass = stim.unlocked ? 'known' : 'unknown';
        const statusText = stim.unlocked ? 'KNOWN' : 'UNKNOWN';
        const pointsText = stim.unlocked ? `${stim.reward_range[0]}â€“${stim.reward_range[1]} pts` : '???';

        html += `
          <div class="arena-fractal ${statusClass}" data-index="${index}">
            ${createFractalHTML(stim, 80)}
            <p style="margin: 3px 0; font-size: 10px; font-weight: bold;">${statusText}</p>
            <p style="margin: 3px 0; font-size: 11px; font-weight: bold;" id="points-${index}">${pointsText}</p>
          </div>
        `;
      });

      html += `</div>
        <div id="arena-submit" style="text-align: center; margin-top: 20px; display: none;">
          <button id="submit-selection" style="padding: 10px 20px; font-size: 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Submit Selection</button>
        </div>
      `;

      return html;
    },
    choices: "NO_KEYS",
    on_load: function() {
      let selectedItems = [];

      document.querySelectorAll(".arena-fractal").forEach((item) => {
        const index = parseInt(item.dataset.index);
        const stim = arena_stimuli[index];

        item.addEventListener("click", () => {
          if (document.getElementById("submit-selection").disabled) return;

          const alreadySelected = selectedItems.find(si => si.index === index);

          if (alreadySelected) {
            // Deselect
            selectedItems = selectedItems.filter(si => si.index !== index);
            item.classList.remove('selected');
          } else if (selectedItems.length < 3) {
            // Just select, DO NOT REVEAL
            selectedItems.push({ index: index, stim: stim });
            item.classList.add('selected');
          }

          // Update display
          document.getElementById("count").textContent = selectedItems.length;
          document.getElementById("arena-submit").style.display = selectedItems.length === 3 ? "block" : "none";
        });
      });

     document.getElementById("submit-selection").addEventListener("click", () => {
      // Disable interaction after submission
      document.querySelectorAll(".arena-fractal").forEach(item => item.style.pointerEvents = "none");
      document.getElementById("submit-selection").disabled = true;

      const selected_ids = [];
      const selected_ranges = [];
      const selected_was_known = [];
      const awarded_points = [];

      selectedItems.forEach(({ stim }) => {
        // Safety check: assign reward if missing or invalid
        if (
          !stim.reward_range ||
          stim.reward_range.length !== 2 ||
          typeof stim.reward_range[0] !== "number"
        ) {
          stim.reward_range = assignRewardRange();
        }

        // Draw points within range
        const [min, max] = stim.reward_range;
        const points = Math.floor(Math.random() * (max - min + 1)) + min;

        //  Save everything for data
        selected_ids.push(stim.id);
        selected_ranges.push(stim.reward_range);
        selected_was_known.push(stim.unlocked);
        awarded_points.push(points);

        //  Mark as unlocked for future use
        stim.unlocked = true;
      });

      const totalPoints = awarded_points.reduce((a, b) => a + b, 0);

      // Finish the Arena trial with all info
      jsPsych.finishTrial({
        trial_type: 'arena',
        selected_stimuli: selected_ids,
        selected_was_known: selected_was_known,
        selected_ranges: selected_ranges,
        awarded_points: awarded_points,
        total_points: totalPoints
      });
    });
    }

  });

  // Final results
  timeline.push({
    type: jsPsychHtmlButtonResponse,
    stimulus: function() {
      const arena_data = jsPsych.data.get().last(1).values()[0];
      const allData = jsPsych.data.get().values();
      const totalPointsEarned = allData
        .filter(trial => trial.points_awarded)
        .reduce((sum, trial) => sum + trial.points_awarded, 0);
      
      const knownSelected = arena_data.selected_was_known.filter(k => k === true).length;
      const unknownSelected = arena_data.selected_was_known.filter(k => k === false).length;
      
      return `
        <div style="text-align: center; max-width: 600px; margin: 0 auto;">
          <h2>Experiment Complete!</h2>
          <h3>Arena Results:</h3>
          <p>You selected ${knownSelected} known and ${unknownSelected} unknown fractals</p>
          <p>You earned <strong>${arena_data.total_points}</strong> points in the Arena!</p>
          <p>Individual selections: ${arena_data.awarded_points.join(', ')} points</p>
          <h3>Total Experiment Points:</h3>
          <p>Arena: <strong>${arena_data.total_points}</strong> points</p>
          <p>Learning phase: <strong>${totalPointsEarned}</strong> points</p>
          <p><strong>Grand Total: ${totalPointsEarned + arena_data.total_points} points</strong></p>
          <br>
          <p>Thank you for participating!</p>
        </div>
      `;
    },
    choices: ['View Data', 'Finish']
  });

  // Run the experiment
  jsPsych.run(timeline);
</script>
</html>
